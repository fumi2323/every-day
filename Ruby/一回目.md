重要なこと
## イテレーション
Rubyの特徴であるプロックとイテレータは、これまであまり見たことがない、  
あるいは使い慣れていないものかもしれない。  
インデックスを使った繰り返し処理や、リストをループする処理の代わりにRubyでは以下の
コードをよく見るようになる。
```
some_list.each do |this_item|
#ここはブロックの中
#this_itemを扱う処理をココに書く。
end
```
全ては値  
式と文に違いはありません。全ては値を持ちます。  
nilであっても例外でありまえん。Rubyでは次のように書くことが可能です。  
```
X = 10
y = 11
z = if x <y
    true
    else
    false
    end
z # =>true
```
シンボルは軽量文字列ではない  
多くのRuby初学者はシンボルが何であるか、どう使えばよいのかを理解するのに苦戦します。  

シンボルは識別子として記述するのに適しています。　シンボルは、そんなものかではなく、  
**何者であるか**が全てです。

`irb`を立ち上げて、次の違いを見てみる。　　
```
:george.object_id == :george.object_id =>true
"george".object_id == "george".object_id =>false
```
`object_id`メソッドはオブジェクトのIDを返します。もし二つのオブジェクトが同じ`object_id`を持っていれば、
それらはメモリ上の同じ実体を指すものであるといえます。

上記で見たとおり、一度でもシンボルを使ったなら、同じ文字からなるシンボルは、いずれも同じメモリ内の  
同じオブジェクトを参照します。  
同じ文字で表された２つのシンボルは、同じ`object_id`を指します。

次に文字列("george")の方を見てみる。`object_id`は一致していません。  
これは、二つの文字列が異なる実態を刺している事を示しています。  
新しい文字列を使うと、Rubyは毎回その文字列のために新しいメモリ領域を確保します。  

シンボルを使うか文字列を使うかで迷ったなら、ハッシュのキーのようにオブジェクトを識別したいのか、それとも前述の"george"など
のようにコンテンツを表したいのかを、選択の指針にしてください。

## すべてはオブジェクト
「全てはオブジェクト」は誇張ではない。クラスや整数でさえオブジェクトです。他のオブジェクトと同じように扱うことができます。

```
# 以下のクラス定義と同じことを行っています
# class MyClass
#   attr_accessor :instance_var
# end
MyClass = Class.new do
   attr?accessor :instance_var
end
```

## 可変な定数
定数は厳密な意味での定数ではありません。初期化済みの定数を変更したとしても、
警告はされますが、プログラムは停止しません。だからといって、定数を再定義するべきだということではありません。

## 
