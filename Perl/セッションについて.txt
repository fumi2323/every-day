今更だけど。
perlのcgi::sessionの話。

Perlで認証系を触るとなるとまず最初に触るであろうセッションのモジュール。

セッションの取扱
CGI::Sessionをよく使うけど
Ajaxなどを利用している場合書き込むタイミングがずれる場合があった


基本的に
セッション
$session = CGI::Session->new(load)({hogehoge});

ってなるけどこのときは一時的にデータを読み込んでいるだけ
プログラムが終わったときに書き込む処理が行われる

sessionオブジェクトはスコープが外れるか？closeが呼ばれる
これ、CPANにちゃんと書いてあった。

流し読みだと結構見逃すので、（お前だけやん）ココに書いておく。

$session = CGI::Session->new();
$session = CGI::Session->load();
どちらでもオブジェクトのスコープが外れるか、プログラムが終了した時点で上書きされる。
上記は読込を行っているので、書き込むまでのタイムラグが発生する。

これを解決するには
読込飲みは別に行うか、セッションモジュールを作るかと思っていた。

だけどちゃんと見てみるとDESTROY();って文字が！！
undef（$session）；では結局書き込んでしまうんで。
DESTROY();を試してみた。

すると。。。

期待通り！！
と思いきや思いっきり期待を裏切られ！！！！
DESTROYで終了時にどうしても書いてしまう

実際良くわかっていないけど、書込を行わない！！
これで情報だけがとれっる！！

ってわかりやすい情報が少ないなぁ。
もしかしれ俺変な使い方してるのかな？

だって、嫌いな言語の1位出し・・・・
でもーそんなの関係なぁーい

やっと、解決策が見つかる！！
そのなもオーバーライド。

結局はDESTROY関数に書込み処理が有るのが行けない
しかもこの関数は不安定なので書き込まれない場合もあるとのこと
ならこのsession内のDESTROY関数をオーバーライド（上書きして）
読み込み専用とかをに変更しちゃえばいい。。

{ #セッション情報の自動上書きを停止
  no warnings 'redefine';
  *CGI::Session::DESTROY = sub{};
}

てな感じを前半に持ってくる

注意。
スコープが外れても書き込まなくなるので書き込みたい場合は
明示的に$session->flush();
を書いておくことを忘れずに。
