#モジュールについての勉強その3

今日の参考は：https://gist.github.com/ywindish/2155288
すごくわかりやすそうだけど、完全には理解できていない。
けど手を動かす。

Perlでオブジェクト指向なコード
use strict;
use warnings;

# 名前空間（パッケージ）の宣言
# すべてのパッケージは暗黙のルートパッケージ main に属する。
package PerlOop;

# コンストラクタ
# 名前はなんでもいいんだけど慣例ではnew。
sub new{
  # 現在のクラス（パッケージ）を取得する
  my $class = shift;
  
  # 引数はハッシュで受けたほうが移植しやすい
  my %param = @_;
  
  # 無名ハッシュをblessしてクラス（パッケージ）と結びつける。
  # bless の第2引数がない場合、カレントパッケージを結びつくが、
  # コンストラクタを継承することを考慮して書く。
  my $self = bless {
    # ハッシュに初期値を設定する
    msg => $param{msg},
  }, $class;
  
  # さらに初期処理が必要な場合はここに書く。
  
  # 生成したハッシュのリファレンスを返す。
  return $self;
}

# インスタンスメソッド
# new　せずに呼ぶとエラーになる。
sub instance_method{
  # パッケージ配下のサブルーチンは、第1引数が少し異なり
  # コンストラクタが返したリファレンスから呼ぶ：　
  # そのリファレンスパッケージ名で修飾して直接呼ぶ：
  # パッケージ名（ただの文字列）となる 
  my $self = shift;
  
  #インスタンス変数（コンストラクタで生成してblessしたハッシュ）へはこのようにアクセスできる。
  print $self->{msg}. "\n";
}

# クラスメソッド
# new しなくても呼べる
sub class_method {
  my $class = shift;
  my $msg = 'I want to go home !!';
  
  # 第一引数を調べる
  if (ref($class)) {
    # リファレンスならインスタンスメソッド
    print 'instance> '. $msg. "\n";
  } else {
    #リファレンスじゃなきゃ文字列。クラスメソッド。
    print 'class> '. $msg. "\n";
  }
}

# デストラクタ
# リファレンスがなくなると自動的に呼ばれる
sub DESTROY {
  print "destroy now.
}


# 継承の話
# 親クラス
package Bace;
sub new {
  my $class = shift;
  my %param = @_;
  my $self = bless {
    basemsg => $param{basemsg},
    }, $class;
    return $self;
  }
  # 子クラス
  package Child;
  sub new {
    my $class = shift;
    my %param = @_;
    
    # 親クラスを作成。ハッシュは共有になる
    my $self = Base->new(basemsg => 'base');
    


    


